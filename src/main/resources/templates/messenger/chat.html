<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
  <link rel="stylesheet" th:href="@{/css/messenger/chat.css}">
</head>

<body>

<div class="chat-window" >

  <!-- ======================= 상단바 ======================= -->
  <div class="chat-header header-purple">
    <div class="chat-header-left">
      <i class="bi bi-chevron-left back-btn"></i>
      <!-- 그룹채팅인 경우 -->
      <div class="chat-title"
           th:if="${groupYn == 'Y'}"
           th:text="${groupName}">
        그룹채팅 이름
      </div>

      <!-- 1:1 채팅인 경우 -->
      <div class="chat-title"
           th:if="${groupYn != 'Y'}"
           th:text="${targetName} + ' ' + ${targetPos}">
        상대방 이름 직급
      </div>
    </div>

    <div class="chat-header-right">
      <!-- 1:1 채팅 상단 고정용 핀 아이콘 -->
      <i class="bi bi-pin-angle-fill pin-icon"></i>
    </div>
  </div>

  <!-- ======================= 메시지 영역 ======================= -->
  <div class="chat-body" id="chat-body">

    <!-- 새 방 안내 -->
    <div class="new-room-empty" id="new-room-empty" th:if="${roomId == null}">
      <div class="empty-guide">
        <span>대화를 시작해보세요.</span>
      </div>
    </div>

    <!-- 메시지 반복 -->
    <div th:each="msg : ${msgList}"
         class="msg-row"
         th:classappend="${msg.senderId} == ${#authentication.principal.empId} ? ' right' : ' left'"
         th:attr="data-msg-id=${msg.msgId}">

      <!-- ===================== 왼쪽 메시지(상대) ===================== -->
      <th:block th:if="${msg.senderId} != ${#authentication.principal.empId}">
        <img src="/images/default_profile.png" class="profile-img">

        <div class="msg-main">
          <div class="sender-name" th:text="${msg.senderName}"></div>
          <div class="msg-bubble msg-left" th:text="${msg.msgContent}"></div>
        </div>

        <div class="msg-time msg-time-left"
             th:text="${#temporals.format(msg.sentDate, 'yyyy-MM-dd a h:mm')}"></div>
      </th:block>

      <!-- ===================== 오른쪽 메시지(나) ===================== -->
      <th:block th:if="${msg.senderId} == ${#authentication.principal.empId}">
        <div class="msg-meta">
          <span th:text="${#temporals.format(msg.sentDate, 'yyyy-MM-dd a h:mm')}"></span>
          <i class="bi bi-check2-all"></i>
        </div>

        <div class="msg-bubble msg-right" th:text="${msg.msgContent}"></div>
      </th:block>

    </div>


  </div>

  <!-- ======================= 입력 영역 ======================= -->
  <div class="chat-footer">
    <textarea id="message" placeholder="메시지를 입력하세요"></textarea>
    <button id="send" class="send-btn">
      <i class="bi bi-send-fill"></i>
    </button>
  </div>

</div>

<script th:inline="javascript">
  const chatBody = document.getElementById('chat-body');
  const textarea = document.getElementById('message');
  const sendBtn = document.getElementById('send');
  const emptyView = document.getElementById('new-room-empty');

  // Thymeleaf에서 내려줄 값
  let roomId = /*[[${roomId}]]*/ '';
  let targetEmpId = /*[[${targetEmpId}]]*/ '';
  const csrfToken = /*[[${_csrf.token}]]*/ '';
  const csrfHeaderName = /*[[${_csrf.headerName}]]*/ '';

  console.log("roomId.... : ", roomId);
  console.log("target..... : ", targetEmpId);
  console.log("token..... : ", csrfToken);
  console.log("headerName..... : ", csrfHeaderName);

  function isNewRoom() {
    return roomId === null || roomId === undefined;
  }

  function hideNewRoomGuide() {
    if (emptyView) emptyView.style.display = 'none';
  }

  function formatTime() {
    const now = new Date();

    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');

    let hour = now.getHours();
    const minute = String(now.getMinutes()).padStart(2, '0');

    const ampm = hour >= 12 ? '오후' : '오전';
    hour = hour % 12 || 12;

    return `${year}-${month}-${day} ${ampm} ${hour}:${minute}`;
  }

  // 내 메시지 DOM 생성
  function appendMyMessage(msg) {
    hideNewRoomGuide();

    const row = document.createElement('div');
    row.className = 'msg-row right';

    row.innerHTML = `
      <div class="msg-meta">
        <span>${formatTime()}</span>
        <i class="bi bi-check2 read-check"></i>
      </div>
      <div class="msg-bubble msg-right">
        ${msg}
      </div>
    `;

    chatBody.appendChild(row);
    chatBody.scrollTop = chatBody.scrollHeight;

    // 체크 → 읽음 표시 바꾸기 (샘플) =====================> 소켓 수정 필요 부분
    setTimeout(() => {
      const icon = row.querySelector('.read-check');
      if (!icon) return;
      icon.classList.remove('bi-check2');
      icon.classList.add('bi-check2-all');
      icon.style.color = '#6a5acd';
    }, 1500);
  }

  // 메시지 전송 로직
  async function sendMessage() {
    const msg = textarea.value.trim();
    if (!msg) return;

    textarea.value = '';
    // height 초기화 후 다시 input 이벤트에서 재계산
    textarea.style.height = '40px';

    appendMyMessage(msg);

    if (isNewRoom()) {
      console.log("신규 채팅방 생성 요청 진입....");
      // 새 방: 방 생성 + 첫 메시지 저장

      const bodyData = {
        members: [targetEmpId],
        groupName : null,
        firstMessage: msg,
        msgType: "TEXT"
      };

      try {
        const res = await fetch('/messenger/chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            [csrfHeaderName]: csrfToken
          },
          body: JSON.stringify(bodyData)
        });
        const data = await res.json();
        roomId = data.roomId;
      } catch (e) {
        console.error('방 생성 실패:', e);
      }
      return;
    }

    // 기존 방: 메시지만 저장
    try {
      const bodyData = {
        msgContent: msg,
        msgType: "TEXT"
      }

      await fetch(`/messenger/chat/${roomId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          [csrfHeaderName]: csrfToken
        },
        body: JSON.stringify(bodyData)
      });
    } catch (e) {
      console.error('메시지 전송 실패:', e);
    }
  }

  // Enter로 전송
  textarea.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });

  sendBtn.addEventListener('click', sendMessage);

//한 줄 높이(px)
const baseHeight = 40;

textarea.addEventListener("input", function () {
 this.style.height = baseHeight + "px"; // 무조건 한 줄에서 시작

 const newHeight = this.scrollHeight;

 // scrollHeight가 기본 한 줄을 넘겼을 때만 증가
 if (newHeight > baseHeight) {
   this.style.height = Math.min(newHeight, 120) + "px";
 }
});

//-------------------------------------------------------
//**여기부터 읽음 처리 코드**
//-------------------------------------------------------

//1) 마지막 메시지 ID 추출 함수
/* function getLastMessageId() {
	const rows = document.querySelectorAll('.msg-row');
	if (rows.length === 0) return null;
	return rows[rows.length - 1].getAttribute('data-msg-id');
}

//2) 읽음 처리 PATCH 호출
async function updateReadMessage() {
	if (!roomId) return;  // 신규 방이면 스킵
	
	const lastMsgId = getLastMessageId();
	if (!lastMsgId) return;
	
	try {
	 await fetch(`/messenger/chat/${roomId}`, {
	   method: "PATCH",
	   headers: {
	     "Content-Type": "application/json",
	     [csrfHeaderName]: csrfToken
	   },
	   body: JSON.stringify({ lastReadId: lastMsgId })
	});
	
	 console.log("읽음 처리 성공:", lastMsgId);
	} catch (e) {
	 console.error("읽음 처리 실패:", e);
	}
}

//3) 방 들어오자마자 자동 읽음 처리
document.addEventListener("DOMContentLoaded", () => {
	updateReadMessage();
}); */
// ===============================> 다시 확인


</script>

</body>
</html>
